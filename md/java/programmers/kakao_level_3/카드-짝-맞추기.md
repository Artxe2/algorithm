최적화 필요
```java
class Solution {
    int answer = 66;

    public int solution(int[][] board, int r, int c) {
        int prev = r * 4 + c;
        int n = 0;
        int index = 0;
        int card;
        int[] yy;
        int[] field = new int[16];
        int[] cost = new int[16];
        int[] start = new int[7];
        int[] end = new int[7];
        boolean[] visit = new boolean[7];
        java.util.Deque<Integer> queue = new java.util.ArrayDeque<>();

        for (int i = 1; i < 7; i++) {
            visit[i] = true;
        }
        for (int y = 0; y < 4; y++) {
            yy = board[y];
            for (int x = 0; x < 4; x++) {
                card = yy[x];
                if (card > 0) {
                    if (visit[card]) {
                        n++;
                        visit[card] = false;
                        start[card] = index;
                    } else {
                        end[card] = index;
                    }
                    field[index] = card;
                }
                index++;
            }
        }
        for (int i = 1; i < 7; i++) {
            if (!visit[i]) {
                backtracking(field, cost, start, end, visit, n, prev, i, 0, queue);
                backtracking(field, cost, end, start, visit, n, prev, i, 0, queue);
            }
        }
        return answer + n * 2;
    }

    void backtracking(int[] field, int[] cost, int[] start, int[] end, boolean[] visit,
            int n, int prev, int index, int count, java.util.Deque<Integer> queue) {
        int from = start[index];
        int to = end[index];

        count += bfs(field, cost, prev, from, queue);
        count += bfs(field, cost, from, to, queue);
        if (--n == 0) {
            if (count < answer) {
                answer = count;
            }
        } else {
            field[from] = 0;
            field[to] = 0;
            visit[index] = true;
            for (int i = 1; i < 7; i++) {
                if (!visit[i]) {
                    backtracking(field, cost, start, end, visit,
                            n, to, i, count, queue);
                    backtracking(field, cost, end, start, visit,
                            n, to, i, count, queue);
                }
            }
            field[from] = index;
            field[to] = index;
            visit[index] = false;
        }
    }

    int bfs(int[] field, int[] cost, int from, int to, java.util.Deque<Integer> queue) {
        if (from == to) {
            return 0;
        }

        int curr;
        int c;
        int move;

        queue.clear();
        fill(cost, 16, 6);
        cost[from] = 0;
        queue.add(from);
        for (;;) {
            curr = queue.pop();
            c = cost[curr] + 1;
            if (curr < 12) {
                move = curr + 4;
                if (move == to) {
                    return c;
                }
                if (cost[move] > c) {
                    cost[move] = c;
                    queue.add(move);
                }
                if (move < 12 && field[move] == 0) {
                    do {
                        move += 4;
                    } while (move < 12 && field[move] == 0);
                    if (move == to) {
                        return c;
                    }
                    if (cost[move] > c) {
                        cost[move] = c;
                        queue.add(move);
                    }
                }

            }
            if (curr > 3) {
                move = curr - 4;
                if (move == to) {
                    return c;
                }
                if (cost[move] > c) {
                    cost[move] = c;
                    queue.add(move);
                }
                if (move > 3 && field[move] == 0) {
                    do {
                        move -= 4;
                    } while (move > 3 && field[move] == 0);
                    if (move == to) {
                        return c;
                    }
                    if (cost[move] > c) {
                        cost[move] = c;
                        queue.add(move);
                    }
                }

            }
            if (curr % 4 < 3) {
                move = curr + 1;
                if (move == to) {
                    return c;
                }
                if (cost[move] > c) {
                    cost[move] = c;
                    queue.add(move);
                }
                if (move % 4 < 3 && field[move] == 0) {
                    do {
                        move++;
                    } while (move % 4 < 3 && field[move] == 0);
                    if (move == to) {
                        return c;
                    }
                    if (cost[move] > c) {
                        cost[move] = c;
                        queue.add(move);
                    }
                }
            }
            if (curr % 4 > 0) {
                move = curr - 1;
                if (move == to) {
                    return c;
                }
                if (cost[move] > c) {
                    cost[move] = c;
                    queue.add(move);
                }
                if (move % 4 > 0 && field[move] == 0) {
                    do {
                        move--;
                    } while (move % 4 > 0 && field[move] == 0);
                    if (move == to) {
                        return c;
                    }
                    if (cost[move] > c) {
                        cost[move] = c;
                        queue.add(move);
                    }
                }
            }
        }
    }

    void fill(int[] array, int length, int value) {
        int index = 1;

        array[0] = value;
        do {
            System.arraycopy(array, 0, array, index, index);
            index += index;
        } while (index + index < length);
        if (index < length) {
            System.arraycopy(array, 0, array, index, length - index);
        }
    }
}
```
 | 정확성 테스트 | 
 |  :-  | 
 | 테스트 1 〉	통과 (0.78ms, 72.6MB) | 
 | 테스트 2 〉	통과 (0.76ms, 78MB) | 
 | 테스트 3 〉	통과 (0.80ms, 74.3MB) | 
 | 테스트 4 〉	통과 (0.73ms, 78.8MB) | 
 | 테스트 5 〉	통과 (2.49ms, 71.8MB) | 
 | 테스트 6 〉	통과 (2.10ms, 76.8MB) | 
 | 테스트 7 〉	통과 (2.58ms, 75.3MB) | 
 | 테스트 8 〉	통과 (2.36ms, 75.1MB) | 
 | 테스트 9 〉	통과 (6.61ms, 83.8MB) | 
 | 테스트 10 〉	통과 (7.19ms, 79.8MB) | 
 | 테스트 11 〉	통과 (6.83ms, 79.3MB) | 
 | 테스트 12 〉	통과 (6.35ms, 82MB) | 
 | 테스트 13 〉	통과 (41.31ms, 91.5MB) | 
 | 테스트 14 〉	통과 (44.88ms, 91.6MB) | 
 | 테스트 15 〉	통과 (32.45ms, 86MB) | 
 | 테스트 16 〉	통과 (41.54ms, 83MB) | 
 | 테스트 17 〉	통과 (0.09ms, 75.1MB) | 
 | 테스트 18 〉	통과 (0.06ms, 75.5MB) | 
 | 테스트 19 〉	통과 (0.25ms, 73.6MB) | 
 | 테스트 20 〉	통과 (0.17ms, 75.2MB) | 
 | 테스트 21 〉	통과 (3.15ms, 75.5MB) | 
 | 테스트 22 〉	통과 (48.50ms, 78.6MB) | 
 | 테스트 23 〉	통과 (47.58ms, 102MB) | 
 | 테스트 24 〉	통과 (2.39ms, 77.3MB) | 
 | 테스트 25 〉	통과 (47.01ms, 93MB) | 
 | 테스트 26 〉	통과 (3.27ms, 79.8MB) | 
 | 테스트 27 〉	통과 (3.50ms, 81.5MB) | 
 | 테스트 28 〉	통과 (0.82ms, 73.4MB) | 
 | 테스트 29 〉	통과 (0.65ms, 76.3MB) | 
 | 테스트 30 〉	통과 (0.79ms, 73.6MB) | 

 | 채점 결과 | 
 | :- | 
 | 정확성: 100.0 | 
 | 합계: 100.0 / 100.0 | 

 || 
 | :- | 
 | 총합 > (357.99ms, 2390.1MB) | 

[문제 보기](https://programmers.co.kr/learn/courses/30/lessons/72415?language=java)